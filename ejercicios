https://play.instruqt.com/hashicorp/tracks/terraform-cloud-aws/challenges/a-sentinel-stands-guard/assignment

Safekeeping Your Terraform State

Your task is to configure remote state using your Terraform Cloud account. In order to complete this challenge you'll need the following:

    A free Terraform Cloud account - log in at https://app.terraform.io
    An organization called yourname-training. You just created this in the previous exercise.
    A workspace named hashicat-aws with its Execution Mode set to Local (not Remote)
    A user token for authentication
    A remote_backend config stored in your workspace

Let's generate a new user token for use on your workstation. Visit the User Settings > Tokens page in Terraform Cloud:

https://app.terraform.io/app/settings/tokens

Click on the Create an API token button. You can name the token whatever you like. Copy the entire token using your mouse or the small copy-paste icon.

Back in the Instruqt track, you need to add your API token to a file called "credentials.tfrc.json". You can do this in two different ways:

The easier way is to select the "Credentials File" tab and open the "/root/.terraform.d/credentials.tfrc.json" file directly.

But if you prefer to use the VS Code Editor, you can use the File > Open menu, click on "..", select ".terraform.d", and then select the "credentials.tfrc.json" file.

In either case, replace the part that says YOURTOKEN with what you copied from Terraform Cloud. If you use the "Credentials File" tab, sure to save the file.

Your token is now safely stored in the "credentials.tfrc.json" file.

Return to your Code Editor tab and edit the "remote_backend.tf" file, replacing the YOURORGANIZATION and YOURWORKSPACE placeholders with your organization name and workspace name.

Also, please edit the "terraform.tfvars" file, setting prefix to your name (first and last with or without a hyphen between them and all lower case) and setting region to a valid AWS region such as "us-east-1", "us-west-1", "eu-west-2", or "ap-southeast-1".

See this page for a list of valid AWS regions.

Uncomment the variable values by removing "# " from each line.

The variables are actually declared in the "variables.tf" file. The "terraform.tfvars" file is just being used to set values for them.

Once you've got all the pieces in place, try running a terraform init and then terraform apply command on the "Shell" tab.

terraform init
terraform apply

Remember to type yes on the "Shell" tab when you are prompted by Terraform to confirm the apply.

When the terraform apply finishes, you should see output like this:

Apply complete! Resources: 41 added, 0 changed, 3 destroyed.

Outputs:

catapp_url = http://ec2-107-22-209-41.compute-1.amazonaws.com

Please click on the URL to test that your application is working. If it won't load, please run the terraform apply command again. That usually fixes this problem.

Additionally, you should see a new state file on the "States" tab of your Terraform Cloud workspace.

Note: If you ran terraform locally before configuring the remote backend, you might have a local state file called terraform.tfstate. If so, please delete it by running rm terraform.tfstate.

Report back to Robin with the Check button below once you've successfully deployed the hashicat application with remote state enabled.

If you'd like to see the hashicat application in your web browser, simply copy the link from the output of your Terraform run, and paste it into the URL bar in another tab or window.

###########################################################
ðŸ” Securing Cloud Credentials

After the AWS credentials issue, the security team is tightening down access to your AWS account. API keys must now be secured as stored variables in Terraform Cloud. Your task is to find your AWS Access Key ID and Secret Access Key, and move them into your workspace as secure environment variables. You'll store the Access Key ID as a plain text environment variable, and the Secret Access Key as a sensitive environment variable. You may also enter optional descriptions for each variable but this is not required to complete the challenge.

In order to complete this challenge you'll need to do the following:

    Find your AWS credentials with the following commands:

echo $AWS_ACCESS_KEY_ID
echo $AWS_SECRET_ACCESS_KEY

    Update the Execution Mode settings in your workspace to Remote on the Settings > General tab.
    Change the Apply Method to "Auto apply" on the same page. This will save you the trouble of having to approve every Terraform run manually. Remember to click the Save button at the bottom of the page!
    Set Environment Variables for your AWS credentials on the Variables tab. Store the AWS_ACCESS_KEY_ID as a regular environment variable, but mark the AWS_SECRET_ACCESS_KEY as sensitive.
    Set Terraform Variables for your prefix and region. Learn more about these variables by looking in the variables.tf file. Set the same values you used in your terraform.tfvars file to avoid all the resources being destroyed and re-created (unless you like waiting longer). NOTE: You must configure these variables on the remote workspace, as they will no longer be read from your local terraform.tfvars file.
    This code has been tested in the us-east-1 region. Note that there are some regions that do not support the t2.micro instance type. If you encounter this, switch your region to us-east-1.

Test your work by running terraform init. Your backend configuration will be updated for remote execution.

Next try running terraform plan. This will trigger what's known as a speculative plan. You can view this plan by copying the link from your "Shell" tab or from your VS Code Editor terminal. (But note that the "Follow Link|Open" mechanism in the terminal does not currently work.) This plan will not show up in your ordinary terraform runs that are triggered via the UI or API. A copy of the plan output will be streamed back to your "Shell" tab.

Run a terraform apply. This apply will show up if you navigate to the runs page in the Terraform Cloud UI.

terraform apply

Congratulations, your AWS keys are now safely encrypted and stored in your Terraform Cloud workspace.

You can continue to run terraform plan and terraform apply in your "Shell" tab, but the execution is now done in Terraform Cloud.

##############################################
ðŸ¤ðŸ¼ Working with Teams in Terraform Cloud

Teams and role-based access controls are a paid feature of Terraform Cloud. You will need to ensure your free trial has been activated from the earlier steps in order to complete this challenge.

In this challenge you'll create teams with different levels of access to your workspace. You can then invite other users to collaborate on code changes, approvals, and Terraform runs.

    Go into your organization's General Settings and click on the Teams link.
    Add a team called admins. Admins should be able to manage policies, manage workspaces, and manage VCS settings. Be sure to click the "Update team organization access" button after checking all 3 checkboxes.
    Add another team called developers. Developers should not have any organization-wide access.
    Add a third team called managers. Managers should also not have any organization-wide access.

Next, assign access rights to the hashicat-aws workspace. Go into the Team Access page of the hashicat-aws workspace settings. If you don't see the Team Access link you might need to log out and back into Terraform Cloud.

You'll want to click the "Add team and permissions" button and then click the "Select team" button next to each team to which you wish to grant workspace access. Then click the "Assign permissions" button for the desired permission.

    Give the admins group admin level access.
    Give the developers group write level access.
    Give the managers group read level access.

Now that you have created teams and given them workspace access you can invite some users to your organization. Return to your General Settings for the organization, and select Users. Then click the "Invite a user" button.

If you're doing an instructor-led training, you can invite your instructor or a fellow student to your organization and place them on the developers team. You'll need the email address attached to their Terraform Cloud account to invite them.

Or you can use one of our example users below:

    workshops+aisha@hashicorp.com
    workshops+lars@hashicorp.com
    workshops+hiro@hashicorp.com

Note that you will not see any users in your organization until they accept your invitations.

You will need at least two users (including yourself) in your organization to pass this challenge. The users you invite do not have to accept the invite to be counted.

################################################
ðŸ’» Version Controlled Infrastructure

In order for different teams and indivdiuals to be able to work on the same Terraform code, you need to use a Version Control System (VCS). Terraform Cloud can integrate with the most popular VCS systems including GitHub, GitLab and Bitbucket.

You will need a free GitHub.com account for this challenge. We recommend using a personal account for training instead your work account (if you have one).

In this challenge your first task is to create a fork of the hashicat-aws repository. Visit this URL and click on the Fork button in the upper right corner to create your own copy of the repo.

https://github.com/hashicorp/hashicat-aws

Note: If you ran this track in the past and already forked the repository, please delete your fork and re-fork it to make sure you are using the latest version and that it does not have changes which you will push to it later in this track. You can delete a repository by clicking on the "Settings" menu of it, scrolling all the way to the bottom of the page, clicking the "Delete this repository" button in the "Danger Zone" section, typing the full repository name, and then clicking the "I understand the consequences, delete this repository" button. Then re-fork the repository as above.

Run the following commands to update your git configuration for your own repository. Don't forget to replace YOURGITUSER with your own git username in the second command.

git remote remove origin
git remote add origin https://github.com/YOURGITUSER/hashicat-aws

If the second command is split across two lines after copying it from the assignment and you are unable to edit it, try making your browser window wider or hiding the assignment termporarily so it fits on one line.

Also run these commands:

git pull
git branch --set-upstream-to=origin/master master
git config --global core.editor "vi"

Next use these commands to set your email and name:

git config --global user.email "you@example.com"

git config --global user.name "Your Name"

To complete your git operations, please commit and push your modified remote_backend.tf file with these commands on your "Shell" tab:

git add .
git commit -m "adding remote backend"
git push origin master

At this time, the last command must be run on the "Shell" tab since authenticating to GitHub from the VS Code Editor's terminal does not work.

Note that you'll have to provide your GitHub username and password or personal access token in order to complete the git push command.

If you have two-factor authentication enabled and don't remember your personal access token, you'll need to create a new one. To do that, log onto GitHub and visit the Tokens page:

https://github.com/settings/tokens

Then click on Personal Access Tokens and generate a new token for the workshop. You can delete it afterwards if you like. This token enables you to push changes from your workstation.

Now that you have your own copy of the hashicat-aws repo to work with, follow the Configuring GitHub Access section of the TFC documentation to connect your GitHub account to your Terraform Organization.

https://www.terraform.io/docs/cloud/vcs/github.html

Make sure you configure an OAuth connection for your organization and not the GitHub App for a single workspace! Once you've configured GitHub access for your organization, you can update your workspace to use your hashicat-aws repository as the source for all Terraform runs. Go into the Settings > Version Control settings page for your workspace. Connect your workspace to the fork of your hashicat-aws repository on GitHub. You can leave all the VCS settings at their defaults.

The first VCS-backed apply should trigger immediately. Click on the Runs tab to view the run in action.

Congratulations, all Terraform changes must now go through version control before they are used in your workspace. This enables you to do code reviews before any changes are pushed to production. It also provides a valuable record of any and all changes made to the code that built your infrastructure. This can prevent configuration drift and undocumented changes.

Click the Check button to let Jane know she can clone the hashicat-aws repo for QA testing.

#################################################################3
ðŸ‘¬ Collaborating with VCS

In this challenge you'll make a small change to the code that deploys the hashicat-aws application, and then create a "Pull Request", which is simply a way of proposing a change and optionally allowing others to review your changes.

Find a partner, or if you're alone you can do this exercise solo. Exchange github usernames and browse to the other person's fork of the hashicat-aws repository. For example:

https://github.com/YOURNAME/hashicat-aws

Please do NOT issue your pull request against the hashicorp/hashicat-aws repository!

Browse to the files/deploy_app.sh file and click on the small pencil icon in the upper right corner of the text area. This will allow you to edit the file right in your browser.

Replace the following text with your own catchy marketing slogan for ACME.

Welcome to ${PREFIX}'s app. Replace this text with your own.

At the bottom of the screen, select the option that says "Create a new branch for this commit and start a pull request." Then, click the "Propose changes" button. Finally, submit a pull request by clicking the "Create pull request" button.

You'll notice that a check is run against your Terraform Cloud workspace. If you right-click the "Details" link of the check and then open the link in a new tab, you'll see the speculative plan that has been run in your workspace.

However, if you do open the link, you might need to refresh the GitHub page in order to see that the check has passed and so that the "Merge pull request" button will be enabled.

Your partner should now review and approve the pull request. Or, if you're working alone you can review your own pull request and merge the changes.

Once you've merged your changes to the master branch, watch the Terraform run that starts in the Terraform Cloud UI.

###################################################3
ðŸ›¡ï¸ Terraform Compliance with Sentinel

In this challenge you'll use Sentinel to enforce a rule that requires any AWS instance created in your account to have the correct billable and department tags.
Challenge Setup

    Create a fork of the following GitHub repo, which contains several Sentinel Policy Sets that you can use in your own organization. As you did with the hashicat-aws repo, use the Fork button in the upper right corner of the screen to create your own copy.

https://github.com/hashicorp/tfc-workshops-sentinel

Note:: If you previously forked this repository before 9/20/2020, please delete your fork and re-fork it to ensure that you are using newer versions of the policies that use the Sentinel v2 imports.

Before moving on, please look at the enforce-mandatory-tags policy. This policy requires all EC2 instances to have Department and Billable tags. It uses some functions from a Sentinel module in a different repository called terraform-guides. You'll find many useful Sentinel policies and functions in its governance/third-generation directory.

    Go into the Organization Settings for your training organization and click on Policy Sets.

    Use the Connect a new policy set button to connect your new GitHub repo to your organization. Remember, the repository is named tfc-workshops-sentinel.

    Under Description you can enter "Sentinel Policies for our AWS resources".

    In the More Options menu set the Policies Path to /aws. This tells Terraform Cloud to use the AWS specific policies that are stored in the repo.

    Leave everything else at its default setting and click on the Connect Policy Set button at the bottom of the page.

You are now ready to begin the challenge.
The Challenge

You'll first need to run a git pull command to pull in the changes you made in the "Collaborating with VCS" challenge:

git pull

Then, add the Department tag with a value of "devops" to the aws_instance resource in your main.tf file.

Then run the following commands to push the change to your forked repository:

git add .
git commit -m "Added the first tag"
git push origin master

These commands mean "add all your changes, commit them to the local git repo, then push them to the master branch of the remote repo." Note that you will have to provide your GitHub credentinals for the git push command.

A plan that successfully runs will be followed by a Sentinel policy check against the enforce-mandatory-tags.sentinel policy. This policy will fail because you have (intentionally) not yet added the Billable tag to your aws_instance resource. As a consequence, you will not be able to apply the run.

Now, add the Billable tag to the aws_instance resource in your main.tf file with a value of "true" and then run these commands to push the change to your repository:

git add .
git commit -m "Added the second tag"
git push origin master

This time, the Sentinel policy should pass because your EC2 instance now has both tags.

Each time you push a change to master, you'll trigger a new Terraform run. Keep trying until you pass the Sentinel policy check.
https://github.com/hashicorp/terraform-guides/tree/master/governance/third-generation
https://github.com/hashicorp/terraform-guides
https://github.com/hashicorp/terraform-guides

#####################################################3clock5h, 1m
notes
ðŸ“š Private Module Registry

In this challenge you'll learn to use the Private Module Registry, which allows you to store and version re-usable modules of Terraform code.

Instead of writing this module from scratch you can copy the existing AWS s3-bucket module from the public Terraform registry. Visit this URL to view the s3-bucket module.

Note the "Source Code" link that points at the GitHub repository for this module. Click on the Source URL. As you did in previous challenges, create your own fork of this repository with the "Fork" button.

Back in the Terraform Cloud UI, click on the "Registry" tab at the top of the page. Click on the "Publish Private Module +" button. Click on the "GitHub" button and select the terraform-aws-s3-bucket repository that you just forked.

Click on the "Publish module" button.

After the module is completely published, please select version 2.2.0 of the module by clicking Change under Version in the upper left section of your screen. If 2.2.0 is not visible, refresh the page once as versions may take a moment to publish.

Create a new Terraform file called s3-bucket.tf in the hashicat-aws directory and use the module in this file to create a new S3 bucket for Gaurav. You can copy the module creation code from the "Provision Instructions" section of the module's page in your Private Module Registry.

Click on the "Inputs" tab of the module. This indicates that you have to specify several module variables (inputs), but they are all marked as optional. We recommend that you set the bucket_prefix module variable (input) to the value of your prefix variable. The AWS provider will then generate a bucket name that starts with your prefix.

Since you are editing a new file, you need to save it even if you are using the VS Code Editor. Use the File > Save menu and type "s3-bucket.tf" for the name. If you are using the Instruqt Text Editor, just click the disk icon above the file.

After you have saved the s3-bucket.tf file, you can add, commit, and push your latest changes to your remote fork. You will be prompted to log onto your github account to push the change.

git add .
git commit -m "Added s3 bucket module"
git push origin master

If all went well you should see a new S3 bucket being built in the console output. Wait until your terraform apply command is complete, then click the Check button to verify your work.
Close

